/*
Welcome to Facebook!

This is just a simple shared plaintext pad, with no execution capabilities.

When you know what language you'd like to use for your interview,
simply choose it from the dropdown in the top bar.

Enjoy your interview!
  

Hello, can you call in?
    
yes

ok, I'm waiting for you to join the call
    
    can you call me the phone number?
    there is some Internet connection issues with comcast, so I am using my phone hotspot
    
    that will be great. my number is 5305742695    
    
Ok, if you can't connect to the meeting in the link, I can call your phone instead
What's your number?
Ok, let me try to call that
*/



/*
Question: Write a function that generates all the permutations of a set of characters and prints them

Input:
{'a', 'b', 'c'}

Output:

abc

acb
bac
bca
cab
cba

        root
    a       b     c
   /  \    /  \
  b    c   a   c
  /
 c 
*/
l.append(1)
dfs(l + [1], 
A + B

    

void permuate(unordered_set<char>& s) {
    unordered_set<char> visited;
    string out;
    permuateDFS(s, 0, visited, out); // here
} 

void permutateDFS(unordered_set<char>& s, int level, unordered_set<char>& visited, string& out) {
    if (level == s.size()) {
        cout < out << endl;
    } else {
        for (auto c : s) {
            //char c = s[i];
            if (visited.find(c) == visited.end()) {
                visited.insert(c);
                out.push_back(c);
                permutateDFS(s, level + 1, visited, out);
                out.pop_out();
                visited.erase(visited.find(c));
            }
        }
    }
    return;
}


// Given a string S consisting of lowercase English alphabets, determine if you can make it a palindrome by removing at most 1 character.


/*
Input: abcdczba
         l  r
Output: True
abcdcba

Input: abcdcba
          lr
Output: True

Input: azbcdcbaz
        l      r
Output: False
*/



bool isValid(string s, int left, int right) {
    while (left < right) {
        if (s[left++] != s[right--]) {
            return False;
        }
    }
    return True;
}

bool canRemoveAtMostOne(string s) {
    left = 0;
    right = s.size() - 1;
    while (left < right) {
        if (s[left] == s[right]) {
            left++; right--;
        } else {
            return (isValid(s, left + 1, right) || isValid(s, left, right - 1));
        }
    }
    return true;
}

string s1
"actor" -> "cat" find analgorm

unicode_str 
hash


















// Dropbox Second Round Phone Interview 
// Oct 24, 2017
 -------------
|            |
|     /\     |
-----/  \----  <--- horizon line
|____________|
  
 -------------
|  *       * |
|     /\     |
|    \ /  *  |
|____________|


Each photograph is divided into a rectangular grid of pixels. For instance, you can
have a photograph that is 3x3.
  
This photograph will have nine pixels.

[][][]
[][][]    
[][][]
  
  
For each pixel in a photo, you assign it a floating point value between 0 and 1 which
represents the likelihood that an edge is going through that pixel. The higher the value, the higher the likelihood.

[0.5][0.7][0.2]
[0.3][0.6][0.4]    
[0.2][0.8][0.5]

A horizon is a contiguous line running left to right across the photo with the addition
limitation that the line cannot go backwards nor straight up or down.
  
----/\/\---- <-- OK

[ ][-][ ]
[-][ ][-]    OK
[ ][ ][ ]
  
[ ][ ][ ]
[-][-][-]    OK
[ ][ ][ ]
  
[ ][-][ ]
[-][ ][ ]    Not OK
[ ][ ][-]

[ ][ ][ ]
[-][-][ ]    Not OK
[ ][-][-]

[ ][ ][ ]
[ ][-][ ]    Not OK
[ ][-][-]

You define the value of a horizon to be the smallest value it traverses (weakest link).
  
 X 
[0.5][0.7][0.2]
      ---
[0.3][0.6][0.4] -> value of this horizon is 0.3
----       ---
[0.2][0.8][0.5]

[0.5][0.7][0.2] -> value of this horizon is 0.2
 ---  --- ---
[0.3][0.6][0.4] 
[0.2][0.8][0.5]

Problem: Given a horizon, calculuate the best (highest) horizon value. Of all valid horizons, find the highest value among them.
  
Ex: If the above were the only two horizons, then the best horizon value would be 0.3.

R
[0.5][0.7][0.2]    
  
[0.3][0.6][0.4] 

[0.2][0.2][0.5]

(0,0) (0,1) (0,2)
[0]  [0.3][0.2]

(1,0)
[0.3] [0.3][0.3] 

[0]   [0.2][0]


recurrence relation
starting point: R(i,0) = X(i,0) initialize zero all for the rest
recurrence relation: R[i, j] = min(max(R[i - 1, j - 1], R[i - 1,j], R[i - 1, j + 1]), X[i, j])


double findBestHorizon(vector<vector<double>>& X) {
    int n = X.size(); // 1<=i<=n
    int m = X[0].size(); // j
    double res = -1;
    // this i for different starting point
    //for (int x = 0; x < n; ++x) {
        vector<vector<double>> R(n, vector<double>(m, 0.0));
        //R[x][0] = X[x][0];
        for (int i = 0; i < n; ++i) {
            R[i][0] = X[i][0];
        }
        // this j is starting of two loop for dp
        for (int j = 1; j < m; ++j) {
            for (int i = 0; i < n; ++i) {
                if (i == 0) {
                    R[i][j] = min(max(R[i][j - 1], R[i + 1][j - 1]), X[i][j]);
                } else if (i == n - 1) {
                    R[i][j] = min(max(R[i - 1][j - 1], R[i][j - 1]), X[i][j]);
                } else {
                    R[i][j] = min(max(R[i - 1][j - 1], R[i][j - 1], R[i + 1][j]), X[i][j]);
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            res = max(res, R[i][m - 1]);
        }
    //}
    return res;
}



   [][][]
   [0][x][] --->
   [0][]
       
       
      [][]
   [0.2][x][]   R(1,1) = min(X(1,1), max(X(0,1), X(0,0), X(0,2)))
      [][]

     
        []     
     [x][]
   [0.3][][]



// Amazon two rounds onsite Oct 20, 2017
// Prime 
unexpected: 
1. grep (use linux command when available rather than algorithms side)
2. Java concepts (important for Amazon supposedly): difference between final, finally, finalize
3. Design Pattern (maybe I should buy a book for this: bought a second-hand book just now)
Others:
- coding questions:
level tree traversal
find one missing number (0-10, e.g.), one only need to calculate the sum, then substract from the supposed total
- machine learning/statistics question (many are random questions in a very very fast pace Q&A fashion)
// Personalization
Mostly behavior questions:
leadership principles
how to do when cannot meet deadline
lower quality or work around 
explain your work to worker/farmer on the street
- coding questions
tree connect nodes in the same level from left to right
dynamic question with backtracking
find minimum steps and record sequence of steps taken for the optimal situation



// Dropbox Oct 10, 2017

// Returns the current time in milliseconds
long getCurrentTimeMillis();

// Called every time we get a hit
void logHit() {
  
}

// Returns the number of hits in the last 5 minutes
long getHits() {
}


// logHit: 1ms        
// getHits: 5minutes 2ms - 0
loghit
// getHits: 5minutes 2ms - 1 


5 * 60 * 1000 

class HitCounter {
  public:
    HitCounter() {
      times.resize(NUM_BUCKETS, 0);
      hits.resize(NUM_BUCKETS, 0);
      last_time_call_get_hits = -NUM_BUCKETS;
      history_times = 0;
    }
  
    void logHit() {
      long curr_time = getCurrentTimeMillis();
      int idx = curr_time % NUM_BUCKETS;
      if (times[idx] == curr_time) {
        hits[idx]++; 
      } else {
        history_times -= hits[idx];
        times[idx] = curr_time;
        hits[idx] = 1;
      }
      history_times++;
      return;
    }
    
    long getHits() {
      long curr_time = getCurrentTimeMillis();
      int res = 0;
      int diff = curr_time - last_time_call_get_hits;
      last_time_call_get_hits = curr_time;
      if (diff > NUM_BUCKETS) {
        for (int i = 0; i < hits.size(); ++i) {
          if (curr_time - times[i] < NUM_BUCKETS) {
            res += hits[i];  
          }
        }
      } else {
        res = history_times;
      }
      history_times = res;
      return res;
    }
    
  
  private:
    const int NUM_BUCKETS = 5 * 60 * 1000;
    vector<int> hits;
    vector<long> times;
    int history_times;
    long last_time_call_get_hits;
    
};


