我的FLAAGD实习面试经验教训
写project report写累了，写下申请总结吧。攒下人品，希望我的股票不要再一星期跌4000刀了。
今年大概是我过去三年找实习最顺利的一年了，虽然到目前为止也就一个fb的offer，其他的要么面完没消息(估计默拒，Apple两个组)，要么还没面就不面了（Microsoft），
要么面挂了(Amazon， Dropbox， Google), 要么进度太慢面了一半（Linkedin）。好像也是这些年拿到面试最多的一次。所以首先想说的是，首先也许总体上找工作是越来越难，
拿到面试也越来越难，但是不代表每个人都越来越难，作为一个人，改变不了总体的情况怎么样，比如说我改变不了税改会怎么变，所以哪怕对奖学金收税，那我也只能想办法
应对，找工作是同样的道理，我们唯一能做的就是让自己的简历更好看，这样可以更容易过简历关，然后提高自己水平，让自己更容易过面试，无论面试官是谁，到底是什么样的
人。 我们不能哭，因为这世界没人同情眼泪，但是不放弃一直努力的人会得到尊重，这是我打篮球懂得的道理，摔倒了就站起来然后fight back。运气可以很差（我经历过因为生病延迟面试然后pass完正好碰到hiring freeze），可以碰到很不好的面试官（正好面完就要离职的面试官，一直在忙自己交接工作一直
敲字然后全程不理你），我们要做的呢就是尽量让自己变得强大，一直努力，不拿到第一个offer就不放弃，或者更好的不拿到很多offer前都不要放弃，把命运掌握在自己
手里永远比把命运交给别人的好。我们一路上会碰到很多人，有的人只和对自己有用的人做朋友，有的人却会真的带你一把给你很多宝贵的建议和帮助，有的人天生高傲以出身为豪，
有的人内心广阔保持谦逊。珍惜那些一直在你身边鼓励你的人，看人不要只看表面，有时候人品比很多其他都重要。我觉得我的导师们是我的榜样，一辈子可以学习的人。
说远了，我和去年比有几个进步，我觉得大家可以借鉴，仅供参考，自己判断合不合适。
1. 我首先选择了从Python换到了C++刷题，因为我之前面试的时候发现了语言鄙视链，很多写Java的engineer也许都不喜欢python，甚至内心对你的第一判断就是你
只会python，去年面SNAP的时候我用python写的，面试官让我一行一行解释，说自己看不懂python。这又提醒了我，大家面试的时候，一定不要表现的过于有自信，
觉得自己啥都会，哪怕面试官水平没你高，不懂你写的高深算法，但是他是面试官就按他的想法走吧，哪怕他是错的，最后写的让他觉得对的也会让你过的。。我有一回
面完发现自己按着面试官写的有bug但是也过了，还有一回硬和面试官死磕，因为我觉得我可以证明我的算法和他的标答是equivalent，花了好久也没有让面试官理解，
最后也挂了哪怕我最后还是写了面试官的标答，我猜feedback是性格不好，有错不肯承认。反正大家就觉得面试官是你的boss就好了，大公司还好，反正也不是你真正的boss，
小公司如果实在不喜欢就选择挂了吧，早结束痛苦更好，别去了最后后悔。我现在真的蛮庆幸我最开始选导师，基本系里所有导师都不要我的，要是要了我，我就没办法选择
新来的老师做我现在喜欢的科研了哈哈，千里马也需要伯乐，特别我这种最开始没找到自己喜欢的内容然后科研做的想退学的人。既然说到了刷题，就继续说说，我觉得
刷题不是目的，刷题对我来说更像是一种做puzzle题的开心，至少之前是这样，等不忙了，还是要继续坚持刷题呀，我觉得刷题然后写博客，可以让更多人看到也是件
很开心的事情，觉得自己对这个世界产生了impact，哪怕你想不到新的解法，但是如果能写的总结深入有趣有启发性，那我觉得也蛮有意思的哈哈，我都不知道有人会
看我在个人网站上写的blog，但是没想到有人和我同学议论 然后我同学给我截了图 然后我都不认识==
2. 提高简历的话，我觉得发顶会论文和之前实习经验是最有效的办法了。我觉得一作顶会还是蛮吸引眼球的，特别如果是oral的话，那开会期间都会认识很多公司
的人，就会有人主动来问你想不想来实习，不过这个时候千万别像我就想当然觉得实习很稳了，其实这个就和refer差不多太多，只是帮助你拿下面试。你这个时候，
该多面还是要多面。然后实习的时候要把握机会，坐我旁边实习的本科生一群人天天3，4点就开始就开始打麻将了。。。我每天搞到5，6点，晚上还继续学习，
还不是为了未来更好的未来。
3. 找到激励自己的办法。对我来，说被人小看，还是蛮激励人的吧。去年我之前一直以为一定会帮我refer的“朋友”最开始不愿意帮我refer给我的感触还是蛮大的吧，
在我最怀疑自己的时候给我更大的打击，连试一试的机会都不愿意给我，说我这样去面试也面不过，还会影响她的refer信用评分。谢谢愿意相信我，素不相识帮我
refer的学长。去年我把人家在朋友圈秀的fb的offer letter截了图，来激励自己，当时就想为了不要自己找房子，为了一个月多几千工资，咱怎么也要再努力一把吧。


## Linkedin Interview 12/5
// Implement the intersection and union operation on sorted lists.
/**
 * @param a a list of non-null integers, in ascending order
 * @param b a list of non-null integers, in ascending order
 * @return the integers that are contained in either a or b, in ascending order
 */
List<Integer> union(List<Integer> a, List<Integer> b);
 
/**
 * @param a a list of non-null integers, in ascending order
 * @param b a list of non-null integers, in ascending order
 * @return the integers that are contained in both a and b, in ascending order
 */
List<Integer> intersect(List<Integer> a, List<Integer> b);

//1  3  4  5
//p1
//2  3  5  5 
//p2
 
//1 2 3 4 5 
//prev = 5 
//1 2 3 4 5 6

//dummy->
//p
//-> 1 2 3 4 5 6
//-> 3 

ListNode*
struct ListNode{
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(NULL) {};
} 

ListNode* union(ListNode* head1, ListNode* head2) {
    ListNode* p1 = head1, *p2 = head2;
    ListNode* dummy = new ListNode(-1);
    ListNode* p = dummy;
    int prev = -1;
    while (!p1 && !p2) {
        if (p1->val <= p2->val) {
            ListNode* node = new ListNode(p1->val);
            p1 = p1->next;
        } else if (p1->val > p2->val) {
            ListNode* node = new ListNode(p2->val);
            p2 = p2->next;
        } 
        if (node->val == prev) continue;
        p->next = node;
        p = p->next;
        prev = p->val;
    }
    while (!p1) {
        ListNode* node = new ListNode(p1->val);
        p1 = p1->next;
        if (node->val == prev) continue;
        p->next = node;
        p = p->next;
        prev = node->val;
    } 
    while (!p2) {
        ListNode* node = new ListNode(p2->val);
        p2 = p2->next;
        if (node->val == prev) continue;
        p->next = node;
        p = p->next;
        prev = node->val;
    } 
    return dummy->next;
}


ListNode* intersect(ListNode* head1, ListNode* head2) { 
    ListNode* p1 = head1, *p2 = head2;
    ListNode* dummy = new ListNode(-1);
    ListNode* p = dummy;
    int prev = -1;
    while (!p1 && !p2) {
        if (p1->val == p2->val) {
            ListNode* node = new ListNode(p1->val);
            p1 = p1->next;
        } else if (p1->val < p2->val){
            p1 = p1->next;
            continue;
        } else {
            p2 = p2->next;
            continue;
        }
        if (node->val == prev) continue;
        p->next = node;
        p = p->next;
        prev = p->val;
    }
    return dummy->next;
}




// Say we have a binary tree, write a function which does a level order traversal on the tree + prints a special character at every level end
struct TreeNode{
    char *val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(char* x): val(x), left(NULL), right(NULL) {};
}

        e .   q [e]
      /  \
      a   b .  q[a b]
    /     \
   c        d
   
   e\n a b \n c d \n
        
void levelTraversal(TreeNode* root){
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()){
        int size = q.size();
        string res = "";
        for (int i = 0; i < size; ++i) {
            TreeNode* node = q.front();
            q.pop();
            res += node->val;
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        cout << res << "\n";
    }
    return;
}




## Linkedin Interview on 11/15
0<=1/(1+exp(-z))<=1
x1, x2, ..., xn \in R^k
w \in R^k
w^T X \in R
z = w^T x 
p(x in class 1) = 1/(1+exp(-w^T x))
log-Likelihood l(w)
log(p(x in class 1)) = -\sum_i (log(1+exp(-W^T x_i))) + |w|_2^2
choose i
w = w - stepsize * grad

1/(1+exp(-w^T x_i) * exp(-w^T x_i) * -x_i + 2 * w
nuclear matrix |X|_* 

/\
\/ 
exp(w1^T x)/(exp(w1^T x) + exp(w2^T x) + ....)

confusion matrix
positive negative
true/false true/false
precision = true positive / all predicted as positive
recall = true positive / all positives
MSE = bias^2 + variance
E(x-

//////////////////////////////////////////////////////////////////////////////////////
Input:
Billions of training examples in a file. Each example has one of 4 class labels
Output:
Select Mc random samples from each class c={1, ..., 4}

reservior sampling

n is number of all in class i
wc -l 
vector<int> class1(k, 0);
vector<int> class2(k, 0);
if (class == 1) {
    selectRandom(stream, k, class1);
} else if (class == 2) {
    selectRandom(stream, k, class2);

// for one class
vector<int> selectRandom(vector<int> stream, int k, vector<int>& reservior) {
    // choose k out of n 
    //vector<int> reservior(k, 0);
    for (int i = 0; i < k; ++i) {
        reservior[i] = stream[i];
    }
    for (int i = k; i < stream.size(); ++i) {
        int j = rand() % (i + 1);
        if (j < k) {
            reservior[j] = stream[i];
        }
    }
    return reservior;
} 

with open("text", "rb") as f:
    for line in f:
        
statement p(each element being selected) = k / n
for the last element 
p(last one) = k / (n - 1) * (n - 1) / n 




Please use this Google doc to code during your interview. To free your hands for coding, we recommend that you use a headset or a phone with speaker option.

Hello? Hi!

Reverse the vowels in a string.

E.g., “the cat” ⇒ “tha cet”
2      5

a e i o u 

Two pointer solution:
Time: O(n)
Memory: O(1)


void reverseInPlace(string& s) {
  if (s.size() == 0) return;
vector<char> vowels{‘a’,’e’,’i’,’o’,’u’};
  int left = 0;
  int right = s.size() - 1;
  while (left < right) {
    while (left < s.size() && vowels.find(s[left]) == vowels.end() )
      left++;
    while (right >= 0 && vowels.find(s[right]) == vowels.end())
      right--;
    if (left < right)
      swap(s[left++], s[right--]);
  }
  return;
}wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww




2. Detect when there have been N failures in the last M seconds.

while (true) {
  DoWork();
  bool did_fail = DidFail();
  if (___________N failures in the last M seconds__________) {
    break;
  }
}

N = 3
M = 2

[----x----|---x-----|x--------|---------]
                     ^ BREAK HERE
 [                   ]



M * 1000 

[time1 time2 time3]


Given API:
getTimeMs() - Returns the current time in milliseconds
DoWork()
DidFail()
M and N are static global constants

vector<int> times;

while (true) {
  DoWork();
  bool did_fail = DidFail();
  int cur = getTimeMs();
  times.push_back(cur);
  if (isNFailureLastMSeconds(N, M)) {
    break;
  }
}
1 3 4  M = 2 N = 2
i = 0 
bool isNFailureLastMSeconds(int N, int M, vector<int>& times) {
  int cnt = 1;
for (int i = times.size() - 2; i >= 0; --i) {
    if (times[times.size() - 1] - times[i]) <= M * 1000 {
      cnt++;  
    } else {
break;
}
  }
  return (cnt >= M); 
}


class EncodedWordDetector { 
public: 
  EncodedWordDetector(const string& secret); 
  bool isPotentiallyEncodedWord(const string& test) const; 

private:
  string secret;
}; 

secret=“banana” test=”cololo” => True
secret=”x” test=”xxxxxx” => False

“b a n a n a”

“c o l o x o ”
b: c
a: o
n: l

c: b
o: a
l: n

bool isPotentiallyEncodedWord(const string& test) const {
  unordered_map<char, char> m1;
  unordered_map<char, char> m2;
  if (secret.size() != test.size()) return false;
  for (int i = 0; i < secret.size(); ++i) {
    char c1 = secret[i], c2 = test[i];
if (m1.find(c1) == m1.end() && m2.find(c2) == m2.end()) {
  m1[c1] = c2;
  m2[c2] = c1;
} else if (m1.find(c1) != m1.end() && m2.find(c2) != m2.end()) {
  if (m1[c1] != c2 || m2[c2] != c1) {
    return false;
  }
} else {
  return false;
}
  }
  return true;
}

EncodedWordDetector(const std::set<string>& secret_words);

“banana” test=”cololo
a: 2   c:1
b: 1   l:2
n: 2   o:2

banana, cloolo, bnaana, 
a:1 3 5 o: 2 3 5, a: 2 3 5
        
a: index array
b:
24 characters
24 letters

length


set<vector<char>> 

secret_words: {banana, cololo, abcdef, hijklm, aaabbb, cccddd}
c l o   b a n 
cololo, banana  => abcbcb   
abcdef, hijklm  => abcdef
aaabbb, cccddd  => aaabbb

abcbcb abcdef aaabbb
aaabbb + 2
cccddd
hashtable key: cololo 
  value: set<string>
vector<unordered_set<string>> 

secret_words: {banana, abcdef, aaabbb}
sum of index

test : eeefff  aaabbb


/*
Welcome to Facebook!

This is just a simple shared plaintext pad, with no execution capabilities.

When you know what language you'd like to use for your interview,
simply choose it from the dropdown in the top bar.

Enjoy your interview!
  

Hello, can you call in?
    
yes

ok, I'm waiting for you to join the call
    
    can you call me the phone number?
    there is some Internet connection issues with comcast, so I am using my phone hotspot
    
    that will be great. my number is 5305742695    
    
Ok, if you can't connect to the meeting in the link, I can call your phone instead
What's your number?
Ok, let me try to call that
*/



/*
Question: Write a function that generates all the permutations of a set of characters and prints them

Input:
{'a', 'b', 'c'}

Output:

abc

acb
bac
bca
cab
cba

        root
    a       b     c
   /  \    /  \
  b    c   a   c
  /
 c 
*/
l.append(1)
dfs(l + [1], 
A + B

    

void permuate(unordered_set<char>& s) {
    unordered_set<char> visited;
    string out;
    permuateDFS(s, 0, visited, out); // here
} 

void permutateDFS(unordered_set<char>& s, int level, unordered_set<char>& visited, string& out) {
    if (level == s.size()) {
        cout < out << endl;
    } else {
        for (auto c : s) {
            //char c = s[i];
            if (visited.find(c) == visited.end()) {
                visited.insert(c);
                out.push_back(c);
                permutateDFS(s, level + 1, visited, out);
                out.pop_out();
                visited.erase(visited.find(c));
            }
        }
    }
    return;
}


// Given a string S consisting of lowercase English alphabets, determine if you can make it a palindrome by removing at most 1 character.


/*
Input: abcdczba
         l  r
Output: True
abcdcba

Input: abcdcba
          lr
Output: True

Input: azbcdcbaz
        l      r
Output: False
*/



bool isValid(string s, int left, int right) {
    while (left < right) {
        if (s[left++] != s[right--]) {
            return False;
        }
    }
    return True;
}

bool canRemoveAtMostOne(string s) {
    left = 0;
    right = s.size() - 1;
    while (left < right) {
        if (s[left] == s[right]) {
            left++; right--;
        } else {
            return (isValid(s, left + 1, right) || isValid(s, left, right - 1));
        }
    }
    return true;
}

string s1
"actor" -> "cat" find analgorm

unicode_str 
hash


















// Dropbox Second Round Phone Interview 
// Oct 24, 2017
 -------------
|            |
|     /\     |
-----/  \----  <--- horizon line
|____________|
  
 -------------
|  *       * |
|     /\     |
|    \ /  *  |
|____________|


Each photograph is divided into a rectangular grid of pixels. For instance, you can
have a photograph that is 3x3.
  
This photograph will have nine pixels.

[][][]
[][][]    
[][][]
  
  
For each pixel in a photo, you assign it a floating point value between 0 and 1 which
represents the likelihood that an edge is going through that pixel. The higher the value, the higher the likelihood.

[0.5][0.7][0.2]
[0.3][0.6][0.4]    
[0.2][0.8][0.5]

A horizon is a contiguous line running left to right across the photo with the addition
limitation that the line cannot go backwards nor straight up or down.
  
----/\/\---- <-- OK

[ ][-][ ]
[-][ ][-]    OK
[ ][ ][ ]
  
[ ][ ][ ]
[-][-][-]    OK
[ ][ ][ ]
  
[ ][-][ ]
[-][ ][ ]    Not OK
[ ][ ][-]

[ ][ ][ ]
[-][-][ ]    Not OK
[ ][-][-]

[ ][ ][ ]
[ ][-][ ]    Not OK
[ ][-][-]

You define the value of a horizon to be the smallest value it traverses (weakest link).
  
 X 
[0.5][0.7][0.2]
      ---
[0.3][0.6][0.4] -> value of this horizon is 0.3
----       ---
[0.2][0.8][0.5]

[0.5][0.7][0.2] -> value of this horizon is 0.2
 ---  --- ---
[0.3][0.6][0.4] 
[0.2][0.8][0.5]

Problem: Given a horizon, calculuate the best (highest) horizon value. Of all valid horizons, find the highest value among them.
  
Ex: If the above were the only two horizons, then the best horizon value would be 0.3.

R
[0.5][0.7][0.2]    
  
[0.3][0.6][0.4] 

[0.2][0.2][0.5]

(0,0) (0,1) (0,2)
[0]  [0.3][0.2]

(1,0)
[0.3] [0.3][0.3] 

[0]   [0.2][0]


recurrence relation
starting point: R(i,0) = X(i,0) initialize zero all for the rest
recurrence relation: R[i, j] = min(max(R[i - 1, j - 1], R[i - 1,j], R[i - 1, j + 1]), X[i, j])


double findBestHorizon(vector<vector<double>>& X) {
    int n = X.size(); // 1<=i<=n
    int m = X[0].size(); // j
    double res = -1;
    // this i for different starting point
    //for (int x = 0; x < n; ++x) {
        vector<vector<double>> R(n, vector<double>(m, 0.0));
        //R[x][0] = X[x][0];
        for (int i = 0; i < n; ++i) {
            R[i][0] = X[i][0];
        }
        // this j is starting of two loop for dp
        for (int j = 1; j < m; ++j) {
            for (int i = 0; i < n; ++i) {
                if (i == 0) {
                    R[i][j] = min(max(R[i][j - 1], R[i + 1][j - 1]), X[i][j]);
                } else if (i == n - 1) {
                    R[i][j] = min(max(R[i - 1][j - 1], R[i][j - 1]), X[i][j]);
                } else {
                    R[i][j] = min(max(R[i - 1][j - 1], R[i][j - 1], R[i + 1][j]), X[i][j]);
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            res = max(res, R[i][m - 1]);
        }
    //}
    return res;
}



   [][][]
   [0][x][] --->
   [0][]
       
       
      [][]
   [0.2][x][]   R(1,1) = min(X(1,1), max(X(0,1), X(0,0), X(0,2)))
      [][]

     
        []     
     [x][]
   [0.3][][]



// Amazon two rounds onsite Oct 20, 2017
// Prime 
unexpected: 
1. grep (use linux command when available rather than algorithms side)
2. Java concepts (important for Amazon supposedly): difference between final, finally, finalize
3. Design Pattern (maybe I should buy a book for this: bought a second-hand book just now)
Others:
- coding questions:
level tree traversal
find one missing number (0-10, e.g.), one only need to calculate the sum, then substract from the supposed total
- machine learning/statistics question (many are random questions in a very very fast pace Q&A fashion)
// Personalization
Mostly behavior questions:
leadership principles
how to do when cannot meet deadline
lower quality or work around 
explain your work to worker/farmer on the street
- coding questions
tree connect nodes in the same level from left to right
dynamic question with backtracking
find minimum steps and record sequence of steps taken for the optimal situation



// Dropbox Oct 10, 2017

// Returns the current time in milliseconds
long getCurrentTimeMillis();

// Called every time we get a hit
void logHit() {
  
}

// Returns the number of hits in the last 5 minutes
long getHits() {
}


// logHit: 1ms        
// getHits: 5minutes 2ms - 0
loghit
// getHits: 5minutes 2ms - 1 


5 * 60 * 1000 

class HitCounter {
  public:
    HitCounter() {
      times.resize(NUM_BUCKETS, 0);
      hits.resize(NUM_BUCKETS, 0);
      last_time_call_get_hits = -NUM_BUCKETS;
      history_times = 0;
    }
  
    void logHit() {
      long curr_time = getCurrentTimeMillis();
      int idx = curr_time % NUM_BUCKETS;
      if (times[idx] == curr_time) {
        hits[idx]++; 
      } else {
        history_times -= hits[idx];
        times[idx] = curr_time;
        hits[idx] = 1;
      }
      history_times++;
      return;
    }
    
    long getHits() {
      long curr_time = getCurrentTimeMillis();
      int res = 0;
      int diff = curr_time - last_time_call_get_hits;
      last_time_call_get_hits = curr_time;
      if (diff > NUM_BUCKETS) {
        for (int i = 0; i < hits.size(); ++i) {
          if (curr_time - times[i] < NUM_BUCKETS) {
            res += hits[i];  
          }
        }
      } else {
        res = history_times;
      }
      history_times = res;
      return res;
    }
    
  
  private:
    const int NUM_BUCKETS = 5 * 60 * 1000;
    vector<int> hits;
    vector<long> times;
    int history_times;
    long last_time_call_get_hits;
    
};


